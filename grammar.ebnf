(* ================================================================ *)
(* Measure Language — Formal Grammar (EBNF)                         *)
(* Version 0.1.0                                                    *)
(*                                                                  *)
(* Measure is a dual-mode language:                                 *)
(*   • Scratch Mode (.msr) — physics-native scripting syntax        *)
(*   • Proof Mode (.lean)  — Lean4 + physics tactics & theory blocks*)
(*                                                                  *)
(* Notation conventions:                                            *)
(*   <rule>       non-terminal                                      *)
(*   'literal'    terminal / keyword                                *)
(*   |            alternation                                       *)
(*   ( )?         optional                                          *)
(*   ( )*         zero or more                                      *)
(*   ( )+         one or more                                       *)
(*   [a-z]        character class                                   *)
(*   (* ... *)    comment                                           *)
(* ================================================================ *)


(* ================================================================ *)
(* PART I — SCRATCH MODE (.msr)                                     *)
(* ================================================================ *)

(* ── 1. Lexical Tokens ────────────────────────────────────────── *)

<letter>            ::= [a-zA-Z] | <unicode-letter>
<digit>             ::= [0-9]
<unicode-letter>    ::= [\u0391-\u03C9]             (* Greek: α-ω *)
                      | [\u2100-\u214F]             (* Letterlike symbols *)

<ident>             ::= <letter> (<letter> | <digit> | '_')*
<greek-ident>       ::= [\u0391-\u03C9] (<letter> | <digit> | '_')*

(* Numeric literals *)
<integer>           ::= <digit>+
<float>             ::= <digit>+ '.' <digit>+ (<exponent>)?
<sci-notation>      ::= <float> ('e' | 'E') ('+' | '-')? <digit>+
<exponent>          ::= ('e' | 'E') ('+' | '-')? <digit>+
<number>            ::= <integer> | <float> | <sci-notation>

(* Uncertainty literal: 1.5 +- 0.01 or 1.5 ± 0.01 *)
<pm-op>             ::= '+-' | '+/-' | '\pm' | '\u00B1'

(* Superscript: both ASCII ^ and Unicode superscripts *)
<superscript>       ::= '^' <atom>
                      | <unicode-superscript>
<unicode-superscript> ::= [\u00B2\u00B3\u2070-\u2079]+

(* Subscript: _ for index notation *)
<subscript>         ::= '_' '{' <index-list> '}'
                      | '_' <ident>

(* Unit tokens *)
<base-unit>         ::= 'kg' | 'm' | 's' | 'A' | 'K' | 'mol' | 'cd'
<derived-unit>      ::= 'N' | 'J' | 'W' | 'Pa' | 'Hz' | 'C' | 'V' | 'eV'
                      | 'GeV' | 'MeV' | 'keV' | 'TeV'
<unit-expr>         ::= <unit-atom> (('*' | '/' | <space>) <unit-atom>)*
<unit-atom>         ::= (<base-unit> | <derived-unit>) (<superscript>)?

(* Whitespace and comments *)
<ws>                ::= ' ' | '\t'
<newline>           ::= '\n' | '\r\n'
<comment>           ::= '--' <any-char>* <newline>
<block-comment>     ::= '/-' <any-char>* '-/'
<indent>            ::= <ws>+                       (* significant indentation *)


(* ── 2. Expressions ───────────────────────────────────────────── *)

<expr>              ::= <let-expr>
                      | <assign-expr>
                      | <arith-expr>
                      | <comparison-expr>
                      | <call-expr>
                      | <if-expr>
                      | <for-expr>
                      | <lambda-expr>

(* Variable declaration with optional type, unit, uncertainty *)
<let-expr>          ::= 'let' <ident> (':' <type-expr>)? '=' <rhs-expr>

(* Right-hand side: value +- uncertainty unit *)
<rhs-expr>          ::= <arith-expr> (<pm-op> <arith-expr>)? (<unit-expr>)?

(* Arithmetic: space = multiplication (juxtaposition) *)
<arith-expr>        ::= <unary-expr> ((<add-op> | <mul-op> | <space>) <unary-expr>)*
<add-op>            ::= '+' | '-'
<mul-op>            ::= '*' | '/'
<unary-expr>        ::= ('-')? <power-expr>
<power-expr>        ::= <atom> (<superscript>)?

(* Atoms *)
<atom>              ::= <number>
                      | <ident>
                      | <greek-ident>
                      | <grouped-expr>
                      | <abs-expr>
                      | <vector-literal>
                      | <matrix-literal>
                      | <db-lookup>

<grouped-expr>      ::= '(' <expr> ')'
<abs-expr>          ::= '|' <expr> '|'

(* Vector and matrix literals *)
<vector-literal>    ::= '[' <expr> (',' <expr>)* ']'
<matrix-literal>    ::= '[' <vector-literal> (';' <vector-literal>)* ']'

(* Comparison *)
<comparison-expr>   ::= <arith-expr> <cmp-op> <arith-expr>
<cmp-op>            ::= '==' | '!=' | '<' | '>' | '<=' | '>='
                      | '\approx' | '\u2248'        (* ≈ approx-equal *)

(* Function call *)
<call-expr>         ::= <ident> '(' <arg-list>? ')'
                      | <ident> <space> <arg-list>  (* juxtaposition call for single arg *)
<arg-list>          ::= <expr> (',' <expr>)*

(* Conditional *)
<if-expr>           ::= 'if' <expr> ':' <block> ('elif' <expr> ':' <block>)* ('else' ':' <block>)?

(* Loop *)
<for-expr>          ::= 'for' <ident> 'in' <range-expr> (':' | 'do') <block>
<range-expr>        ::= <expr> '..' <expr> ('step' <expr>)?

(* Lambda *)
<lambda-expr>       ::= 'fun' <param-list> '=>' <expr>
<param-list>        ::= '(' <param> (',' <param>)* ')'
<param>             ::= <ident> (':' <type-expr>)?


(* ── 3. Declarations ──────────────────────────────────────────── *)

<program>           ::= <module-decl>? <declaration>*

<module-decl>       ::= 'module' <ident> <newline>

<declaration>       ::= <let-expr>
                      | <def-decl>
                      | <simulation-block>
                      | <compute-stmt>
                      | <verify-stmt>
                      | <import-stmt>
                      | <attribute> <declaration>

(* Function definition *)
<def-decl>          ::= 'def' <ident> <param-list> ('->' <type-expr>)? ':' <block>

(* Import *)
<import-stmt>       ::= 'import' <module-path>
                      | 'from' <module-path> 'import' <ident-list>
<module-path>       ::= <ident> ('.' <ident>)*
<ident-list>        ::= <ident> (',' <ident>)*

(* Attributes: @[...] *)
<attribute>         ::= '@[' <attr-entry> (',' <attr-entry>)* ']'
<attr-entry>        ::= <ident> (<attr-arg>)*
<attr-arg>          ::= <ident> | <number> | <string>


(* ── 4. Simulation Block ─────────────────────────────────────── *)

<simulation-block>  ::= <attribute>* 'simulation' <ident> ':' <newline>
                         <indent> <sim-body>

<sim-body>          ::= <sim-init> <sim-loop>
<sim-init>          ::= (<let-expr> <newline>)*

<sim-loop>          ::= 'for' <ident> 'in' <range-expr> ':' <newline>
                         <indent> <sim-step>+

<sim-step>          ::= <ident> "'" '=' <expr>     (* primed update: v' = v + a*dt *)
                      | <let-expr>
                      | <call-expr>
                      | <assert-stmt>
                      | <emit-stmt>

<assert-stmt>       ::= 'assert' <expr> (<string>)?
<emit-stmt>         ::= 'emit' <ident> '=' <expr>


(* ── 5. External Computation ──────────────────────────────────── *)

<compute-stmt>      ::= 'let' <ident> '=' 'compute' <engine-name> ':' <compute-body>
                      | 'let' <ident> '=' 'compute' <engine-name> '{' <compute-args> '}'

<engine-name>       ::= 'Julia' | 'Mathematica' | 'Python' | <ident>

<compute-body>      ::= <expr>
                      | <newline> <indent> <expr>+

<compute-args>      ::= <kv-pair> (',' <kv-pair>)*
<kv-pair>           ::= <ident> ':=' <expr>


(* ── 6. Verification ──────────────────────────────────────────── *)

<verify-stmt>       ::= 'verify' <ident> ('where' | ':') <newline>
                         <indent> <verify-clause>+
                      | 'verify' <expr>

<verify-clause>     ::= <ident> ':=' <expr>


(* ── 7. Juxtaposition Disambiguation ─────────────────────────── *)

(* Space-means-multiply precedence rules:                          *)
(*   <ident> <ident>       → multiplication                        *)
(*   <ident> '(' ...       → function call                         *)
(*   <number> <ident>      → multiplication                        *)
(*   <ident> <superscript> → power binds tighter than juxtapose    *)
(*   <known-fn> <atom>     → function call (single arg)            *)
(*   '(' <expr> ')' <atom> → multiplication                        *)
(*                                                                  *)
(* Known functions: sin, cos, tan, exp, log, ln, sqrt, abs,        *)
(*   div, curl, grad, laplacian, det, tr, fft, ifft                *)


(* ================================================================ *)
(* PART II — PROOF MODE (Lean4 extensions)                          *)
(* ================================================================ *)

(* ── 8. Theory Block ──────────────────────────────────────────── *)

<theory-block>      ::= <attribute>* 'theory' <ident> ('extends' <ident-list>)? 'where'
                         <newline> <indent> <theory-member>*

<theory-member>     ::= <axiom-decl>
                      | <theorem-decl>
                      | <def-decl>
                      | <notation-decl>
                      | <open-stmt>
                      | <attribute> <theory-member>


(* ── 9. Axiom and Theorem Declarations ────────────────────────── *)

<axiom-decl>        ::= <attribute>* 'axiom' <ident> <binder>* ':' <prop-expr>

<theorem-decl>      ::= <attribute>* 'theorem' <ident> <binder>* ':' <prop-expr>
                         ':=' <proof-term>
                      |  <attribute>* 'theorem' <ident> <binder>* ':' <prop-expr>
                         ':=' 'by' <tactic-block>

(* Binders (Lean4-compatible) *)
<binder>            ::= '(' <ident>+ ':' <type-expr> ')'       (* explicit *)
                      | '{' <ident>+ ':' <type-expr> '}'       (* implicit *)
                      | '[' <ident>+ ':' <type-expr> ']'       (* instance *)
                      | <ident>                                 (* anonymous *)

(* Proposition expressions *)
<prop-expr>         ::= <type-expr>
                      | <forall-expr>
                      | <exists-expr>
                      | <prop-expr> <logical-op> <prop-expr>
                      | <negation>

<forall-expr>       ::= ('forall' | '∀') <binder>+ ',' <prop-expr>
<exists-expr>       ::= ('exists' | '∃') <binder>+ ',' <prop-expr>
<logical-op>        ::= '∧' | '∨' | '→' | '↔'
<negation>          ::= '¬' <prop-expr>

(* Type expressions with dimensional annotations *)
<type-expr>         ::= <ident>
                      | <type-expr> <type-expr>                 (* application *)
                      | <type-expr> '×' <type-expr>             (* product *)
                      | <type-expr> '→' <type-expr>             (* function *)
                      | 'Quantity' <dim-expr>                    (* dimensioned quantity *)
                      | 'VectorField' <superscript>? <ident>
                      | 'ScalarField' <ident>

<dim-expr>          ::= <ident>                                 (* named: Energy, Force *)
                      | '⟨' <int-list> '⟩'                      (* literal: ⟨2,1,-2,0,0,0,0⟩ *)
<int-list>          ::= <integer> (',' <integer>)*


(* ── 10. Physics Tactics ──────────────────────────────────────── *)

<tactic-block>      ::= <tactic> (<newline> <indent> <tactic>)*

<tactic>            ::= <lean4-tactic>              (* all standard Lean4 tactics *)
                      | <physics-tactic>

<physics-tactic>    ::= <dim-check>
                      | <conserve>
                      | <approximate>
                      | <by-symmetry>
                      | <limit-of>
                      | <tensor-contract>
                      | <gauge-transform>

(* dim_check — verify dimensional consistency *)
<dim-check>         ::= 'dim_check'
                      | 'dim_check' 'at' <ident>
                      | 'dim_check' <expr> '=' <expr>

(* conserve — prove conservation law *)
<conserve>          ::= 'conserve' <conserved-qty>+ ('across' <ident>)?
<conserved-qty>     ::= 'energy' | 'momentum' | 'angular_momentum'
                      | 'charge' | 'lepton_number' | 'baryon_number'
                      | <ident>

(* approximate — introduce controlled approximation *)
<approximate>       ::= 'approximate' <approx-spec> ('to_order' <integer>)?
<approx-spec>       ::= <ident> '≈' <expr>
                      | 'neglect' <ident>+
                      | 'taylor' <ident> 'around' <expr>
                      | 'small' <ident> ('<' <expr>)?

(* by_symmetry — exploit symmetry *)
<by-symmetry>       ::= 'by_symmetry' <symmetry-type> ('of' <ident>)?
<symmetry-type>     ::= 'rotational' | 'translational' | 'gauge'
                      | 'time_reversal' | 'parity' | 'CPT'
                      | 'Lorentz' | 'conformal' | 'scale'
                      | <ident>

(* limit_of — take a physical limit *)
<limit-of>          ::= 'limit_of' <limit-spec>
<limit-spec>        ::= <ident> '→' <expr>
                      | <ident> '→' '0'
                      | <ident> '≪' <ident>

(* tensor_contract — contract tensor indices *)
<tensor-contract>   ::= 'tensor_contract' ('at' <ident>)?
                      | 'tensor_contract' 'indices' <index-list>

(* gauge_transform — apply gauge transformation *)
<gauge-transform>   ::= 'gauge_transform' <ident> 'by' <expr>


(* ── 11. Physics Attributes ───────────────────────────────────── *)

<phys-attribute>    ::= '@[' <phys-attr-entry> (',' <phys-attr-entry>)* ']'

<phys-attr-entry>   ::= 'rigor' <rigor-level>
                      | 'uncertainty' <uncertainty-model>
                      | 'approximation_of' <ident> ',' 'limit' '(' <limit-spec> ')'
                      | 'conservation' <conserved-qty>+
                      | 'tolerance' <number>
                      | 'checkpoint' 'every' <integer>
                      | 'runtime_check' <ident> <ident>+ (',' 'tolerance' <number>)?
                      | 'database' <ident>

<rigor-level>       ::= 'strict' | 'approximate' | 'empirical' | 'numerical'
<uncertainty-model> ::= 'Gaussian' | 'Interval' | 'Affine' | <ident>


(* ── 12. Database Lookup ──────────────────────────────────────── *)

<db-lookup>         ::= <ident> '.' <ident>                    (* NIST.c, PDG.electron *)
                      | 'from' <ident> 'import' <ident-list>


(* ================================================================ *)
(* END OF GRAMMAR                                                   *)
(* ================================================================ *)
